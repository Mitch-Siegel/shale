#include "uart.sbh"
#include "spinlock.sbh"

class Uart
{
    Spinlock lock;

    // TODO: #define for buffer size
    u8[32] txBuffer;
    u8 txWriteLoc;
    u8 txReadLoc;
};

Uart uart;

// TODO: synchronization & locking
// TODO: proper UART buffering/wait on UART status


fun uart_init()
{
    Spinlock_Init(&(uart.lock), "Uart Lock");

    // TODO: define for uart register reads/writes
    u8 *uartMmioBase = 0x10000000;

    *(uartMmioBase + 1) = 0x00; // disable interrupts

    *(uartMmioBase + 3) = (1 << 7); // mode to set baud rate

    *(uartMmioBase) = 0x03; // LSB for 38.4Kbps

    *(uartMmioBase + 1) = 0x00; // MSB for 38.4Kbps

    *(uartMmioBase + 3) = 3; // reset, enable FIFOs

    *(uartMmioBase + 1) = (1 << 1) | (1); // enable TX and RX interrupts
}

// if the UART is idle and there's something in the tx buffer, write it
fun uart_transmit()
{
    u8 *uartMmioBase = 0x10000000;

    while(1 == 1)
    {
        if(uart.txWriteLoc == uart.txReadLoc)
        {
            return;
        }

        if((*(uartMmioBase + 5) & (1 << 5)) == 0)
        {
            return;
        }

        u8 bufferOffset = uart.txReadLoc; // TODO: put back inside bracket operator
        u8 toWrite = uart.txBuffer[bufferOffset];
        uart.txReadLoc += 1;

        uart.txReadLoc %= 32; // TODO: #define for buffer size

        // TODO: wake up anyone waiting on uart.txReadLoc to put more chars into the buffer

        *(uartMmioBase + 0) = toWrite;
        
    }
}

fun uart_putc(u32 c)
{
    Spinlock_Acquire(&uart.lock);
    u8 *uartMmioBase = 0x10000000;
    // TODO: #define for buffer size
    while(uart.txWriteLoc == uart.txReadLoc + 32)
    {
        // TODO: sleep on the value of uart.txReadLoc, wait for space to be opened up for us in the buffer
        *uartMmioBase = '!';
    }

    uart.txBuffer[uart.txWriteLoc] = c;
    uart.txWriteLoc += 1;
    
    uart.txWriteLoc %= 32; // TODO: #define for buffer size


    uart_transmit();
    Spinlock_Release(&uart.lock);
}
