#include "uart.sbh"
#include "arch/interrupts.sbh"

class Uart
{
    Spinlock lock;

    // TODO: #define for buffer size
    u8[32] txBuffer;
    u8 txWriteLoc;
    u8 txReadLoc;
};

Uart uart;

// TODO: synchronization & locking
// TODO: proper UART buffering/wait on UART status


fun uart_init()
{
    Spinlock_Init(&(uart.lock), "Uart Lock");

    // TODO: define for uart register reads/writes
    u8 *uartMmioBase = 0x10000000;

    *(uartMmioBase + 1) = 0x00; // disable interrupts

    *(uartMmioBase + 3) = (1 << 7); // mode to set baud rate

    *(uartMmioBase) = 0x03; // LSB for 38.4Kbps

    *(uartMmioBase + 1) = 0x00; // MSB for 38.4Kbps

    *(uartMmioBase + 3) = 3; // reset, enable FIFOs

    *(uartMmioBase + 1) = (1 << 1) | (1); // enable TX and RX interrupts
}

// if the UART is idle and there's something in the tx buffer, write it
fun uart_transmit()
{
    u8 *uartMmioBase = 0x10000000;

    while(1 == 1)
    {
        if(uart.txWriteLoc == uart.txReadLoc)
        {
            return;
        }

        if((*(uartMmioBase + 5) & (1 << 5)) == 0)
        {
            return;
        }

        u8 bufferOffset = uart.txReadLoc; // TODO: put back inside bracket operator
        u8 toWrite = *(uart.txBuffer + bufferOffset); // TODO: use bracket operators once implemented as child of t_dot
        uart.txReadLoc += 1;

        uart.txReadLoc %= 32; // TODO: #define for buffer size

        // TODO: wake up anyone waiting on uart.txReadLoc to put more chars into the buffer

        *(uartMmioBase + 0) = toWrite;
        
    }
}

fun uart_putc(u32 c)
{
    Spinlock_Acquire(&uart.lock);
    u8 *uartMmioBase = 0x10000000;
    // TODO: #define for buffer size
    while(uart.txWriteLoc == uart.txReadLoc + 32)
    {
        // TODO: sleep on the value of uart.txReadLoc, wait for space to be opened up for us in the buffer
        *uartMmioBase = '!';
    }

    u8 bufferOffset = uart.txWriteLoc; // TODO: put back inside bracket operator
    *(uart.txBuffer + bufferOffset) = c; // TODO: use bracket operators once implemented as child of t_dot
    uart.txWriteLoc += 1;
    
    uart.txWriteLoc %= 32; // TODO: #define for buffer size


    uart_transmit();
    Spinlock_Release(&uart.lock);
}

// spin waiting for the uart output register to be empty, then barf up the character into the register
fun uart_putc_sync(u32 c)
{
    push_off();

    u8 *LSR = 0x10000005;
    u8 *THR = 0x10000000;

    while(((*LSR) & (1 << 5)) == 0)
    {
    }

    (*THR) = c;

    pop_off();
}
